
services:
  # NGINX with ngx-inference module dynamically loaded
  nginx:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ngx-inference-nginx
    ports:
      - "8081:80"
    depends_on:
      - extproc-bbr
      - extproc-epp
      - echo-server
    # Default bridge network DNS provides service-name resolution at 127.0.0.11
    # No extra env needed; nginx.conf already uses resolver 127.0.0.11 and service names.

  # Mock External Processor for BBR (Body-Based Routing) listening on :9000
  extproc-bbr:
    build:
      context: .
      dockerfile: docker/extproc.Dockerfile
    container_name: extproc-bbr
    command: ["extproc_mock", "0.0.0.0:9000"]
    environment:
      # The mock will emit this upstream in headers so the module can route requests there.
      - EPP_UPSTREAM=echo-server:80
      - BBR_MODEL=bbr-chosen-model

  # Mock External Processor for EPP (Endpoint Picker Processor) listening on :9001
  extproc-epp:
    build:
      context: .
      dockerfile: docker/extproc.Dockerfile
    container_name: extproc-epp
    command: ["extproc_mock", "0.0.0.0:9001"]
    environment:
      # Same upstream for both mocks: the nginx module will pick what it needs (EPP/BBR).
      - EPP_UPSTREAM=echo-server:80
      - BBR_MODEL=bbr-chosen-model

  # Simple upstream service the module should route to based on ext-proc header
  # Using a lightweight echo server so you can see headers/body in the response.
  echo-server:
    image: ealen/echo-server:latest
    container_name: echo-server
    # Listens on port 80 by default and echoes request details
    # No published port needed; nginx routes internally via service name

# All services share the default network allowing DNS resolution by service name.
# Access the stack via: curl -i http://localhost:8080/
