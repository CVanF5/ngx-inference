# nginx.conf for open-source NGINX dynamically loading the ngx-inference module
#
# This configuration demonstrates:
#  - Loading the Rust-built dynamic module: libngx_inference.so
#  - Example directives for BBR (Body-Based Routing) and EPP (Endpoint Picker Processor)
#  - Using $inference_upstream variable (exposed by the module) in proxy_pass
#  - DNS resolver for variable-based proxy_pass targets
#
# Notes:
#  - The module sets/reads headers:
#      * BBR returns a model header (default: X-Gateway-Model-Name)
#      * EPP returns an upstream endpoint header (default: X-Inference-Upstream)
#    The module exposes the $inference_upstream variable which mirrors the EPP header.
#  - proxy_pass with a variable requires a resolver; set this to your environment's DNS.
#    In Docker: 127.0.0.11. In Kubernetes: kube-dns/ CoreDNS ClusterIP (e.g. 10.96.0.10).
#  - The EPP should return a host:port or resolvable name:port so NGINX can dynamically route.

load_module /usr/lib/nginx/modules/libngx_inference.so;

user  www-data;
worker_processes auto;

error_log  /var/log/nginx/error.log info;
pid        /var/run/nginx.pid;

events {
  worker_connections  1024;
}

http {
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;

  log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'upstream="$upstream_addr" upstream_status="$upstream_status" '
                    'rt="$request_time" urt="$upstream_response_time"';

  access_log  /var/log/nginx/access.log  main;

  sendfile        on;
  keepalive_timeout  65;

  # Resolver is required when proxy_pass uses a variable
  # Docker default DNS:
  resolver 127.0.0.11 ipv6=off valid=30s;
  # For Docker, you can change to:
  # resolver 127.0.0.11 ipv6=off valid=30s;
  # For Kubernetes (example):
  # resolver 10.96.0.10 ipv6=off valid=30s;

  # Optional: map the module variable to a target with a fallback when EPP doesn't provide one
  # - If $inference_upstream is empty, use "echo-server:80" as a default backend.
  map $inference_upstream $target_upstream {
    ""       "echo-server:80";   # fallback backend (set to something reachable in your env)
    default  $inference_upstream;
  }

  server {
    listen       80;
    server_name  _;

    # -----------------------------
    # Proxy and Body Handling
    # -----------------------------

    # If you want to stream request bodies to upstream rather than fully buffer:
    # proxy_request_buffering off;

    # Consider body buffering limits in your environment
    # client_max_body_size 10m;
    # client_body_buffer_size 512k;

    location / {
      # -----------------------------
      # Inference Module Directives
      # -----------------------------

      # BBR (Body-Based Routing) configuration:
      # Enable/disable BBR logic
      inference_bbr on;
      # gRPC ext-proc endpoint for the BBR reference implementation (example service name/port)
      inference_bbr_endpoint extproc-bbr:9000;
      # Body chunk size to send over gRPC (<= 65536 recommended)
      inference_bbr_chunk_size 65536;
      # Timeout (milliseconds) for the BBR ext-proc call
      inference_bbr_timeout_ms 200;
      # Fail-open if ext-proc is unavailable (on) or fail-closed (off)
      inference_bbr_failure_mode_allow on;
      # Optional: override the header name used by BBR to return the model
      # inference_bbr_header_name X-Gateway-Model-Name;

      # EPP (Endpoint Picker Processor) configuration:
      # Enable/disable EPP logic
      inference_epp on;
      # gRPC ext-proc endpoint for the EPP implementation
      inference_epp_endpoint extproc-epp:9001;
      # Timeout (milliseconds) for the EPP ext-proc call
      inference_epp_timeout_ms 200;
      # Fail-open if ext-proc is unavailable (on) or fail-closed (off)
      inference_epp_failure_mode_allow on;
      # Optional: override the upstream header name used by EPP
      # inference_epp_header_name X-Inference-Upstream;

      # proxy headers
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header Connection "";

      # Route to the dynamically selected upstream from EPP, else fallback via map()
      proxy_pass http://$target_upstream;
    }

    # Simple health endpoint for container checks
    location = /healthz {
      add_header Content-Type text/plain;
      return 200 'ok';
    }
  }
}
